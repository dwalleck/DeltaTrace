using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace DeltaTrace;

[Generator]
public class DeltaTrace : ISourceGenerator
{
    private static MemberDeclarationSyntax ParseMember(string code)
    {
        var tree = CSharpSyntaxTree.ParseText($"public class Dummy {{ {code} }}");
        var root = tree.GetCompilationUnitRoot();
        var classDeclaration = root.DescendantNodes().OfType<ClassDeclarationSyntax>().First();
        return classDeclaration.Members.First();
    }

    private static List<MemberDeclarationSyntax> ParseMembers(string code)
    {
        var tree = CSharpSyntaxTree.ParseText($"public class Dummy {{ {code} }}");
        var root = tree.GetCompilationUnitRoot();
        var classDeclaration = root.DescendantNodes().OfType<ClassDeclarationSyntax>().First();
        return classDeclaration.Members.ToList();
    }
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new DeltaTraceSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (!(context.SyntaxReceiver is DeltaTraceSyntaxReceiver receiver))
            return;

        // Get the attribute symbols
        var deltaTraceAttribute = context.Compilation.GetTypeByMetadataName("DeltaTrace.DeltaTraceAttribute");
        var ignoreDeltaAttribute = context.Compilation.GetTypeByMetadataName("DeltaTrace.IgnoreDeltaAttribute");

        if (deltaTraceAttribute == null)
            return;

        // Generate base classes first
        GenerateBaseClasses(context);

        // Process each type with [DeltaTrace]
        foreach (var typeDeclaration in receiver.CandidateTypes)
        {
            var model = context.Compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(typeDeclaration);

            var deltaTraceAttr = typeSymbol?.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Equals(deltaTraceAttribute, SymbolEqualityComparer.Default) == true);

            if (deltaTraceAttr == null)
                continue;

            // Generate the delta tracker for this type
            var compilationUnit = GenerateDeltaTracker(typeSymbol, deltaTraceAttr, ignoreDeltaAttribute!);
            var source = compilationUnit.NormalizeWhitespace().ToFullString();

            context.AddSource($"{typeSymbol.Name}Delta.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private void GenerateBaseClasses(GeneratorExecutionContext context)
    {
        var source = @"// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;

namespace DeltaTrace.Generated
{
    public sealed class PropertyDelta<T>
    {
        public string PropertyName { get; }
        public T PreviousValue { get; }
        public T CurrentValue { get; }
        public bool HasChanged { get; }

        public PropertyDelta(string propertyName, T previousValue, T currentValue)
        {
            PropertyName = propertyName;
            PreviousValue = previousValue;
            CurrentValue = currentValue;
            HasChanged = !EqualityComparer<T>.Default.Equals(previousValue, currentValue);
        }

        public PropertyChange ToPropertyChange() => 
            new PropertyChange(PropertyName, PreviousValue, CurrentValue, typeof(T));
    }

    public sealed class PropertyChange
    {
        public string PropertyPath { get; }
        public object? OldValue { get; }
        public object? NewValue { get; }
        public Type PropertyType { get; }

        public PropertyChange(string propertyPath, object? oldValue, object? newValue, Type propertyType)
        {
            PropertyPath = propertyPath;
            OldValue = oldValue;
            NewValue = newValue;
            PropertyType = propertyType;
        }

        public PropertyChange WithPrefix(string prefix) => 
            new PropertyChange($""{prefix}.{PropertyPath}"", OldValue, NewValue, PropertyType);
    }

    public sealed class DeltaInfo
    {
        public string PropertyPath { get; }
        public object? PreviousValue { get; }
        public object? CurrentValue { get; }
        public Type PropertyType { get; }

        public DeltaInfo(string propertyPath, object? previousValue, object? currentValue, Type propertyType)
        {
            PropertyPath = propertyPath;
            PreviousValue = previousValue;
            CurrentValue = currentValue;
            PropertyType = propertyType;
        }
    }

    public interface IDeltaTracker
    {
        bool HasAnyDeltas { get; }
        IEnumerable<DeltaInfo> GetAllDeltas();
    }
}";

        context.AddSource("DeltaTraceBase.g.cs", SourceText.From(source, Encoding.UTF8));
    }


    private CompilationUnitSyntax GenerateDeltaTracker(
        INamedTypeSymbol typeSymbol,
        AttributeData deltaTraceAttr,
        INamedTypeSymbol? ignoreDeltaAttribute)
    {
        var options = ParseDeltaTraceOptions(deltaTraceAttr);
        var deltaClassName = $"{typeSymbol.Name}{options.DeltaSuffix}";
        var properties = GetTrackableProperties(typeSymbol, ignoreDeltaAttribute);

        var sb = new StringBuilder();
        sb.AppendLine(@"// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using DeltaTrace.Generated;");

        sb.AppendLine($@"
namespace {typeSymbol.ContainingNamespace.ToDisplayString()}
{{");

        // Generate the main delta tracker class
        sb.Append(GenerateDeltaClassString(typeSymbol, deltaClassName, properties, options));

        // Generate extension methods if requested
        if (options.GenerateExtensions)
        {
            sb.Append(GenerateExtensionClassString(typeSymbol, deltaClassName));
        }

        sb.AppendLine("}");

        return CSharpSyntaxTree.ParseText(sb.ToString()).GetCompilationUnitRoot();
    }

    private string GenerateDeltaClassString(INamedTypeSymbol typeSymbol, string deltaClassName, List<IPropertySymbol> properties, DeltaTraceOptions options)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine($@"
    public sealed class {deltaClassName} : IDeltaTracker
    {{
        private readonly {typeSymbol.Name}? _previous;
        private readonly {typeSymbol.Name}? _current;");

        // Generate lazy fields
        foreach (var property in properties)
        {
            var fieldName = $"_{char.ToLower(property.Name[0])}{property.Name.Substring(1)}Delta";
            var propertyType = property.Type.ToDisplayString();
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                sb.AppendLine($"        private readonly Lazy<{property.Type.Name}{options.DeltaSuffix}> {fieldName};");
            }
            else
            {
                sb.AppendLine($"        private readonly Lazy<PropertyDelta<{propertyType}>> {fieldName};");
            }
        }

        // Constructor
        sb.AppendLine($@"
        public {deltaClassName}({typeSymbol.Name}? previous, {typeSymbol.Name}? current)
        {{
            _previous = previous;
            _current = current;");

        foreach (var property in properties)
        {
            var fieldName = $"_{char.ToLower(property.Name[0])}{property.Name.Substring(1)}Delta";
            var propertyType = property.Type.ToDisplayString();
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                sb.AppendLine($@"
            {fieldName} = new Lazy<{property.Type.Name}{options.DeltaSuffix}>(() => 
                new {property.Type.Name}{options.DeltaSuffix}(_previous?.{property.Name}, _current?.{property.Name}));");
            }
            else
            {
                sb.AppendLine($@"
            {fieldName} = new Lazy<PropertyDelta<{propertyType}>>(() => 
                new PropertyDelta<{propertyType}>(
                    ""{property.Name}"",
                    _previous != null ? _previous.{property.Name}! : default({propertyType})!,
                    _current != null ? _current.{property.Name}! : default({propertyType})!));");
            }
        }

        sb.AppendLine("        }");

        // Property accessors
        foreach (var property in properties)
        {
            var fieldName = $"_{char.ToLower(property.Name[0])}{property.Name.Substring(1)}Delta";
            var propertyType = property.Type.ToDisplayString();
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                sb.AppendLine($@"
        public {property.Type.Name}{options.DeltaSuffix} {property.Name} => {fieldName}.Value;");
            }
            else
            {
                sb.AppendLine($@"
        public PropertyDelta<{propertyType}> {property.Name} => {fieldName}.Value;");
            }
        }

        // HasAnyDeltas property
        sb.AppendLine(@"
        public bool HasAnyDeltas
        {
            get
            {
                if (_previous == null || _current == null)
                    return _previous != _current;
                
                return ");

        var conditions = new List<string>();
        foreach (var property in properties)
        {
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                conditions.Add($"{property.Name}.HasAnyDeltas");
            }
            else
            {
                conditions.Add($"{property.Name}.HasChanged");
            }
        }

        if (conditions.Count > 0)
        {
            sb.AppendLine($"                {string.Join(" || \n                ", conditions)};");
        }
        else
        {
            sb.AppendLine("                false;");
        }

        sb.AppendLine("            }");
        sb.AppendLine("        }");

        // GetAllDeltas method
        sb.AppendLine(@"
        public IEnumerable<DeltaInfo> GetAllDeltas()
        {
            if (_previous == null || _current == null)
            {
                yield return new DeltaInfo(""<root>"", _previous, _current, typeof(" + typeSymbol.Name + @"));
                yield break;
            }");

        foreach (var property in properties)
        {
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                sb.AppendLine($@"
            foreach (var delta in {property.Name}.GetAllDeltas())
            {{
                yield return new DeltaInfo($""{property.Name}.{{delta.PropertyPath}}"", delta.PreviousValue, delta.CurrentValue, delta.PropertyType);
            }}");
            }
            else
            {
                sb.AppendLine($@"
            if ({property.Name}.HasChanged)
            {{
                yield return new DeltaInfo(""{property.Name}"", {property.Name}.PreviousValue, {property.Name}.CurrentValue, typeof({property.Type.ToDisplayString()}));
            }}");
            }
        }

        sb.AppendLine("        }");

        // GetDeltas method (returns PropertyChange objects)
        sb.AppendLine(@"
        public IEnumerable<PropertyChange> GetDeltas()
        {
            if (_previous == null || _current == null)
            {
                yield return new PropertyChange(""<root>"", _previous, _current, typeof(" + typeSymbol.Name + @"));
                yield break;
            }");

        foreach (var property in properties)
        {
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                sb.AppendLine($@"
            foreach (var delta in {property.Name}.GetDeltas())
            {{
                yield return delta.WithPrefix(""{property.Name}"");
            }}");
            }
            else
            {
                sb.AppendLine($@"
            if ({property.Name}.HasChanged)
            {{
                yield return {property.Name}.ToPropertyChange();
            }}");
            }
        }

        sb.AppendLine("        }");

        // HasDeltaIn method
        sb.AppendLine($@"
        public bool HasDeltaIn<TProp>(Func<{deltaClassName}, PropertyDelta<TProp>> selector)
        {{
            return selector(this).HasChanged;
        }}

        public bool HasDeltaIn(Func<{deltaClassName}, IDeltaTracker> selector)
        {{
            return selector(this).HasAnyDeltas;
        }}");

        // GetRootDeltas method (for backwards compatibility)
        sb.AppendLine(@"
        public IEnumerable<DeltaInfo> GetRootDeltas()
        {");

        foreach (var property in properties)
        {
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            var condition = isTrackableType && options.DeepTracking
                ? $"{property.Name}.HasAnyDeltas"
                : $"{property.Name}.HasChanged";

            sb.AppendLine($@"
            if ({condition})
            {{
                yield return new DeltaInfo(""{property.Name}"", _previous?.{property.Name}, _current?.{property.Name}, typeof({property.Type.ToDisplayString()}));
            }}");
        }

        sb.AppendLine("        }");
        sb.AppendLine("    }");

        return sb.ToString();
    }

    private string GenerateExtensionClassString(INamedTypeSymbol typeSymbol, string deltaClassName)
    {
        return $@"
    public static class {typeSymbol.Name}DeltaExtensions
    {{
        public static {deltaClassName} GetDelta(this {typeSymbol.Name}? previous, {typeSymbol.Name}? current) => 
            new {deltaClassName}(previous, current);

        public static {deltaClassName} GetDeltaFrom(this {typeSymbol.Name}? current, {typeSymbol.Name}? previous) => 
            new {deltaClassName}(previous, current);
    }}";
    }

    private List<IPropertySymbol> GetTrackableProperties(INamedTypeSymbol typeSymbol, INamedTypeSymbol? ignoreAttribute)
    {
        return typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public)
            .Where(p => !p.IsStatic)
            .Where(p => !p.IsIndexer)
            .Where(p => p.GetMethod != null)
            .Where(p => ignoreAttribute == null || !p.GetAttributes()
                .Any(a => a.AttributeClass?.Equals(ignoreAttribute, SymbolEqualityComparer.Default) == true))
            .ToList();
    }

    private DeltaTraceOptions ParseDeltaTraceOptions(AttributeData attribute)
    {
        var options = new DeltaTraceOptions();

        foreach (var arg in attribute.NamedArguments)
        {
            switch (arg.Key)
            {
                case "DeepTracking":
                    if (arg.Value.Value is bool deepTracking)
                        options.DeepTracking = deepTracking;
                    break;
                case "GenerateExtensions":
                    if (arg.Value.Value is bool generateExtensions)
                        options.GenerateExtensions = generateExtensions;
                    break;
                case "GenerateJsonSupport":
                    if (arg.Value.Value is bool generateJsonSupport)
                        options.GenerateJsonSupport = generateJsonSupport;
                    break;
                case "DeltaSuffix":
                    options.DeltaSuffix = arg.Value.Value as string ?? "Delta";
                    break;
            }
        }

        return options;
    }

    private class DeltaTraceOptions
    {
        public bool DeepTracking { get; set; } = true;
        public bool GenerateExtensions { get; set; } = true;
        public bool GenerateJsonSupport { get; set; } = false;
        public string DeltaSuffix { get; set; } = "Delta";
    }

    public class DeltaTraceSyntaxReceiver : ISyntaxReceiver
    {
        public List<TypeDeclarationSyntax> CandidateTypes { get; } = new List<TypeDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is TypeDeclarationSyntax { AttributeLists.Count: > 0 } typeDeclaration)
            {
                CandidateTypes.Add(typeDeclaration);
            }
        }
    }
}