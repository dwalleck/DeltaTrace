using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace DeltaTrace;

/// <summary>
/// A source generator that creates delta tracking classes for types marked with the [DeltaTrace] attribute.
/// </summary>
[Generator]
public class DeltaTraceGenerator : IIncrementalGenerator
{
    private static MemberDeclarationSyntax ParseMember(string code)
    {
        var tree = CSharpSyntaxTree.ParseText($"public class Dummy {{ {code} }}");
        var root = tree.GetCompilationUnitRoot();
        var classDeclaration = root.DescendantNodes().OfType<ClassDeclarationSyntax>().First();
        return classDeclaration.Members.First();
    }

    private static List<MemberDeclarationSyntax> ParseMembers(string code)
    {
        var tree = CSharpSyntaxTree.ParseText($"public class Dummy {{ {code} }}");
        var root = tree.GetCompilationUnitRoot();
        var classDeclaration = root.DescendantNodes().OfType<ClassDeclarationSyntax>().First();
        return classDeclaration.Members.ToList();
    }
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Generate base classes once
        context.RegisterPostInitializationOutput(ctx => GenerateBaseClasses(ctx));

        // Create a syntax provider for types with attributes
        var typeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation to get attribute symbols
        var compilationAndTypes = context.CompilationProvider
            .Combine(typeDeclarations.Collect());

        // Generate output for each type
        context.RegisterSourceOutput(compilationAndTypes,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsCandidateForGeneration(SyntaxNode node)
    {
        return node is TypeDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static TypeDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;

        // Check if it has any attribute that could be DeltaTrace
        foreach (var attributeList in typeDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
                if (symbol is not IMethodSymbol attributeSymbol)
                    continue;

                var attributeType = attributeSymbol.ContainingType;
                var fullName = attributeType.ToDisplayString();

                if (fullName == "DeltaTrace.DeltaTraceAttribute" || 
                    fullName == "DeltaTraceAttribute" ||
                    attributeType.Name == "DeltaTraceAttribute")
                {
                    return typeDeclaration;
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
            return;

        // Get the attribute symbols
        var deltaTraceAttribute = compilation.GetTypeByMetadataName("DeltaTrace.DeltaTraceAttribute");
        var ignoreDeltaAttribute = compilation.GetTypeByMetadataName("DeltaTrace.IgnoreDeltaAttribute");

        if (deltaTraceAttribute == null)
            return;

        // Process each type
        foreach (var typeDeclaration in types.Distinct())
        {
            var model = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(typeDeclaration);

            if (typeSymbol == null)
                continue;

            var deltaTraceAttr = typeSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Equals(deltaTraceAttribute, SymbolEqualityComparer.Default) == true);

            if (deltaTraceAttr == null)
                continue;

            // Generate the delta tracker for this type
            var compilationUnit = GenerateDeltaTracker(typeSymbol, deltaTraceAttr, ignoreDeltaAttribute);
            var source = compilationUnit.NormalizeWhitespace().ToFullString();

            context.AddSource($"{typeSymbol.Name}Delta.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static void GenerateBaseClasses(IncrementalGeneratorPostInitializationContext context)
    {
        var source = @"// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;

namespace DeltaTrace.Generated
{
    public sealed class PropertyDelta<T>
    {
        public string PropertyName { get; }
        public T PreviousValue { get; }
        public T CurrentValue { get; }
        public bool HasChanged { get; }

        public PropertyDelta(string propertyName, T previousValue, T currentValue)
        {
            PropertyName = propertyName;
            PreviousValue = previousValue;
            CurrentValue = currentValue;
            HasChanged = !EqualityComparer<T>.Default.Equals(previousValue, currentValue);
        }

        public PropertyChange ToPropertyChange() => 
            new PropertyChange(PropertyName, PreviousValue, CurrentValue, typeof(T));
    }

    public sealed class PropertyChange
    {
        public string PropertyPath { get; }
        public object? OldValue { get; }
        public object? NewValue { get; }
        public Type PropertyType { get; }

        public PropertyChange(string propertyPath, object? oldValue, object? newValue, Type propertyType)
        {
            PropertyPath = propertyPath;
            OldValue = oldValue;
            NewValue = newValue;
            PropertyType = propertyType;
        }

        public PropertyChange WithPrefix(string prefix) => 
            new PropertyChange($""{prefix}.{PropertyPath}"", OldValue, NewValue, PropertyType);
    }

    public sealed class DeltaInfo
    {
        public string PropertyPath { get; }
        public object? PreviousValue { get; }
        public object? CurrentValue { get; }
        public Type PropertyType { get; }

        public DeltaInfo(string propertyPath, object? previousValue, object? currentValue, Type propertyType)
        {
            PropertyPath = propertyPath;
            PreviousValue = previousValue;
            CurrentValue = currentValue;
            PropertyType = propertyType;
        }
    }

    public interface IDeltaTracker
    {
        bool HasAnyDeltas { get; }
        IEnumerable<DeltaInfo> GetAllDeltas();
    }
}";

        context.AddSource("DeltaTraceBase.g.cs", SourceText.From(source, Encoding.UTF8));
    }


    private static CompilationUnitSyntax GenerateDeltaTracker(
        INamedTypeSymbol typeSymbol,
        AttributeData deltaTraceAttr,
        INamedTypeSymbol? ignoreDeltaAttribute)
    {
        var options = ParseDeltaTraceOptions(deltaTraceAttr);
        var deltaClassName = $"{typeSymbol.Name}{options.DeltaSuffix}";
        var properties = GetTrackableProperties(typeSymbol, ignoreDeltaAttribute);

        var sb = new StringBuilder();
        sb.AppendLine(@"// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using DeltaTrace.Generated;");

        sb.AppendLine($@"
namespace {typeSymbol.ContainingNamespace.ToDisplayString()}
{{");

        // Generate the main delta tracker class
        sb.Append(GenerateDeltaClassString(typeSymbol, deltaClassName, properties, options));

        // Generate extension methods if requested
        if (options.GenerateExtensions)
        {
            sb.Append(GenerateExtensionClassString(typeSymbol, deltaClassName));
        }

        sb.AppendLine("}");

        return CSharpSyntaxTree.ParseText(sb.ToString()).GetCompilationUnitRoot();
    }

    private static string GenerateDeltaClassString(INamedTypeSymbol typeSymbol, string deltaClassName, List<IPropertySymbol> properties, DeltaTraceOptions options)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine($@"
    public sealed class {deltaClassName} : IDeltaTracker
    {{
        private readonly {typeSymbol.Name}? _previous;
        private readonly {typeSymbol.Name}? _current;");

        // Generate lazy fields
        foreach (var property in properties)
        {
            var fieldName = $"_{char.ToLower(property.Name[0])}{property.Name.Substring(1)}Delta";
            var propertyType = property.Type.ToDisplayString();
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                sb.AppendLine($"        private readonly Lazy<{property.Type.Name}{options.DeltaSuffix}> {fieldName};");
            }
            else
            {
                sb.AppendLine($"        private readonly Lazy<PropertyDelta<{propertyType}>> {fieldName};");
            }
        }

        // Constructor
        sb.AppendLine($@"
        public {deltaClassName}({typeSymbol.Name}? previous, {typeSymbol.Name}? current)
        {{
            _previous = previous;
            _current = current;");

        foreach (var property in properties)
        {
            var fieldName = $"_{char.ToLower(property.Name[0])}{property.Name.Substring(1)}Delta";
            var propertyType = property.Type.ToDisplayString();
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                sb.AppendLine($@"
            {fieldName} = new Lazy<{property.Type.Name}{options.DeltaSuffix}>(() => 
                new {property.Type.Name}{options.DeltaSuffix}(_previous?.{property.Name}, _current?.{property.Name}));");
            }
            else
            {
                sb.AppendLine($@"
            {fieldName} = new Lazy<PropertyDelta<{propertyType}>>(() => 
                new PropertyDelta<{propertyType}>(
                    ""{property.Name}"",
                    _previous != null ? _previous.{property.Name}! : default({propertyType})!,
                    _current != null ? _current.{property.Name}! : default({propertyType})!));");
            }
        }

        sb.AppendLine("        }");

        // Property accessors
        foreach (var property in properties)
        {
            var fieldName = $"_{char.ToLower(property.Name[0])}{property.Name.Substring(1)}Delta";
            var propertyType = property.Type.ToDisplayString();
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                sb.AppendLine($@"
        public {property.Type.Name}{options.DeltaSuffix} {property.Name} => {fieldName}.Value;");
            }
            else
            {
                sb.AppendLine($@"
        public PropertyDelta<{propertyType}> {property.Name} => {fieldName}.Value;");
            }
        }

        // HasAnyDeltas property
        sb.AppendLine(@"
        public bool HasAnyDeltas
        {
            get
            {
                if (_previous == null || _current == null)
                    return _previous != _current;
                
                return ");

        var conditions = new List<string>();
        foreach (var property in properties)
        {
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                conditions.Add($"{property.Name}.HasAnyDeltas");
            }
            else
            {
                conditions.Add($"{property.Name}.HasChanged");
            }
        }

        if (conditions.Count > 0)
        {
            sb.AppendLine($"                {string.Join(" || \n                ", conditions)};");
        }
        else
        {
            sb.AppendLine("                false;");
        }

        sb.AppendLine("            }");
        sb.AppendLine("        }");

        // GetAllDeltas method
        sb.AppendLine(@"
        public IEnumerable<DeltaInfo> GetAllDeltas()
        {
            if (_previous == null || _current == null)
            {
                yield return new DeltaInfo(""<root>"", _previous, _current, typeof(" + typeSymbol.Name + @"));
                yield break;
            }");

        foreach (var property in properties)
        {
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                sb.AppendLine($@"
            foreach (var delta in {property.Name}.GetAllDeltas())
            {{
                yield return new DeltaInfo($""{property.Name}.{{delta.PropertyPath}}"", delta.PreviousValue, delta.CurrentValue, delta.PropertyType);
            }}");
            }
            else
            {
                sb.AppendLine($@"
            if ({property.Name}.HasChanged)
            {{
                yield return new DeltaInfo(""{property.Name}"", {property.Name}.PreviousValue, {property.Name}.CurrentValue, typeof({property.Type.ToDisplayString()}));
            }}");
            }
        }

        sb.AppendLine("        }");

        // GetDeltas method (returns PropertyChange objects)
        sb.AppendLine(@"
        public IEnumerable<PropertyChange> GetDeltas()
        {
            if (_previous == null || _current == null)
            {
                yield return new PropertyChange(""<root>"", _previous, _current, typeof(" + typeSymbol.Name + @"));
                yield break;
            }");

        foreach (var property in properties)
        {
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            if (isTrackableType && options.DeepTracking)
            {
                sb.AppendLine($@"
            foreach (var delta in {property.Name}.GetDeltas())
            {{
                yield return delta.WithPrefix(""{property.Name}"");
            }}");
            }
            else
            {
                sb.AppendLine($@"
            if ({property.Name}.HasChanged)
            {{
                yield return {property.Name}.ToPropertyChange();
            }}");
            }
        }

        sb.AppendLine("        }");

        // HasDeltaIn method
        sb.AppendLine($@"
        public bool HasDeltaIn<TProp>(Func<{deltaClassName}, PropertyDelta<TProp>> selector)
        {{
            return selector(this).HasChanged;
        }}

        public bool HasDeltaIn(Func<{deltaClassName}, IDeltaTracker> selector)
        {{
            return selector(this).HasAnyDeltas;
        }}");

        // GetRootDeltas method (for backwards compatibility)
        sb.AppendLine(@"
        public IEnumerable<DeltaInfo> GetRootDeltas()
        {");

        foreach (var property in properties)
        {
            var isTrackableType = property.Type.GetAttributes()
                .Any(a => a.AttributeClass?.Name == "DeltaTraceAttribute");

            var condition = isTrackableType && options.DeepTracking
                ? $"{property.Name}.HasAnyDeltas"
                : $"{property.Name}.HasChanged";

            sb.AppendLine($@"
            if ({condition})
            {{
                yield return new DeltaInfo(""{property.Name}"", _previous?.{property.Name}, _current?.{property.Name}, typeof({property.Type.ToDisplayString()}));
            }}");
        }

        sb.AppendLine("        }");
        sb.AppendLine("    }");

        return sb.ToString();
    }

    private static string GenerateExtensionClassString(INamedTypeSymbol typeSymbol, string deltaClassName)
    {
        return $@"
    public static class {typeSymbol.Name}DeltaExtensions
    {{
        public static {deltaClassName} GetDelta(this {typeSymbol.Name}? previous, {typeSymbol.Name}? current) => 
            new {deltaClassName}(previous, current);

        public static {deltaClassName} GetDeltaFrom(this {typeSymbol.Name}? current, {typeSymbol.Name}? previous) => 
            new {deltaClassName}(previous, current);
    }}";
    }

    private static List<IPropertySymbol> GetTrackableProperties(INamedTypeSymbol typeSymbol, INamedTypeSymbol? ignoreAttribute)
    {
        return typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public)
            .Where(p => !p.IsStatic)
            .Where(p => !p.IsIndexer)
            .Where(p => p.GetMethod != null)
            .Where(p => ignoreAttribute == null || !p.GetAttributes()
                .Any(a => a.AttributeClass?.Equals(ignoreAttribute, SymbolEqualityComparer.Default) == true))
            .ToList();
    }

    private static DeltaTraceOptions ParseDeltaTraceOptions(AttributeData attribute)
    {
        var options = new DeltaTraceOptions();

        foreach (var arg in attribute.NamedArguments)
        {
            switch (arg.Key)
            {
                case "DeepTracking":
                    if (arg.Value.Value is bool deepTracking)
                        options.DeepTracking = deepTracking;
                    break;
                case "GenerateExtensions":
                    if (arg.Value.Value is bool generateExtensions)
                        options.GenerateExtensions = generateExtensions;
                    break;
                case "GenerateJsonSupport":
                    if (arg.Value.Value is bool generateJsonSupport)
                        options.GenerateJsonSupport = generateJsonSupport;
                    break;
                case "DeltaSuffix":
                    options.DeltaSuffix = arg.Value.Value as string ?? "Delta";
                    break;
            }
        }

        return options;
    }

    private class DeltaTraceOptions
    {
        public bool DeepTracking { get; set; } = true;
        public bool GenerateExtensions { get; set; } = true;
        public bool GenerateJsonSupport { get; set; } = false;
        public string DeltaSuffix { get; set; } = "Delta";
    }

}