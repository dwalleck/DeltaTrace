using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace DeltaTrace.Benchmarks;

/// <summary>
/// Old ISourceGenerator implementation for benchmark comparison
/// </summary>
public class DeltaTraceGeneratorOld : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new DeltaTraceSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (!(context.SyntaxReceiver is DeltaTraceSyntaxReceiver receiver))
            return;

        // Get the attribute symbols
        var deltaTraceAttribute = context.Compilation.GetTypeByMetadataName("DeltaTrace.DeltaTraceAttribute");
        var ignoreDeltaAttribute = context.Compilation.GetTypeByMetadataName("DeltaTrace.IgnoreDeltaAttribute");

        if (deltaTraceAttribute == null)
            return;

        // Generate base classes first
        GenerateBaseClasses(context);

        // Process each type with [DeltaTrace]
        foreach (var typeDeclaration in receiver.CandidateTypes)
        {
            var model = context.Compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(typeDeclaration);

            if (typeSymbol == null)
                continue;

            var deltaTraceAttr = typeSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Equals(deltaTraceAttribute, SymbolEqualityComparer.Default) == true);

            if (deltaTraceAttr == null)
                continue;

            // Generate the delta tracker for this type
            var source = GenerateDeltaTrackerSource(typeSymbol, deltaTraceAttr, ignoreDeltaAttribute!);
            context.AddSource($"{typeSymbol.Name}Delta.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private void GenerateBaseClasses(GeneratorExecutionContext context)
    {
        var source = @"// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;

namespace DeltaTrace.Generated
{
    public sealed class PropertyDelta<T>
    {
        public string PropertyName { get; }
        public T PreviousValue { get; }
        public T CurrentValue { get; }
        public bool HasChanged { get; }

        public PropertyDelta(string propertyName, T previousValue, T currentValue)
        {
            PropertyName = propertyName;
            PreviousValue = previousValue;
            CurrentValue = currentValue;
            HasChanged = !EqualityComparer<T>.Default.Equals(previousValue, currentValue);
        }
    }

    public interface IDeltaTracker
    {
        bool HasAnyDeltas { get; }
    }
}";

        context.AddSource("DeltaTraceBase.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private string GenerateDeltaTrackerSource(INamedTypeSymbol typeSymbol, AttributeData deltaTraceAttr, INamedTypeSymbol ignoreDeltaAttribute)
    {
        // Simplified version - just enough for benchmarking
        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public)
            .Where(p => !p.IsStatic)
            .Where(p => !p.IsIndexer)
            .Where(p => p.GetMethod != null)
            .ToList();

        var sb = new StringBuilder();
        sb.AppendLine(@"// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using DeltaTrace.Generated;");

        sb.AppendLine($@"
namespace {typeSymbol.ContainingNamespace.ToDisplayString()}
{{
    public sealed class {typeSymbol.Name}Delta : IDeltaTracker
    {{
        private readonly {typeSymbol.Name}? _previous;
        private readonly {typeSymbol.Name}? _current;");

        // Generate lazy fields
        foreach (var property in properties)
        {
            var fieldName = $"_{char.ToLower(property.Name[0])}{property.Name.Substring(1)}Delta";
            var propertyType = property.Type.ToDisplayString();
            sb.AppendLine($"        private readonly Lazy<PropertyDelta<{propertyType}>> {fieldName};");
        }

        // Constructor
        sb.AppendLine($@"
        public {typeSymbol.Name}Delta({typeSymbol.Name}? previous, {typeSymbol.Name}? current)
        {{
            _previous = previous;
            _current = current;");

        foreach (var property in properties)
        {
            var fieldName = $"_{char.ToLower(property.Name[0])}{property.Name.Substring(1)}Delta";
            var propertyType = property.Type.ToDisplayString();
            sb.AppendLine($@"
            {fieldName} = new Lazy<PropertyDelta<{propertyType}>>(() => 
                new PropertyDelta<{propertyType}>(
                    ""{property.Name}"",
                    _previous != null ? _previous.{property.Name}! : default({propertyType})!,
                    _current != null ? _current.{property.Name}! : default({propertyType})!));");
        }

        sb.AppendLine("        }");

        // HasAnyDeltas property
        sb.AppendLine(@"
        public bool HasAnyDeltas
        {
            get
            {
                if (_previous == null || _current == null)
                    return _previous != _current;
                
                return ");

        var conditions = properties.Select(p => $"{char.ToLower(p.Name[0])}{p.Name.Substring(1)}Delta.Value.HasChanged");
        sb.AppendLine($"                {string.Join(" || ", conditions)};");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    public class DeltaTraceSyntaxReceiver : ISyntaxReceiver
    {
        public List<TypeDeclarationSyntax> CandidateTypes { get; } = new List<TypeDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is TypeDeclarationSyntax { AttributeLists.Count: > 0 } typeDeclaration)
            {
                CandidateTypes.Add(typeDeclaration);
            }
        }
    }
}